<?xml version="1.0" encoding="Cp1252"?>
<pmd-cpd>
<duplication lines="184" tokens="829">
<file line="31" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\HTMLMetaProcessor.java"/>
<file line="31" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\HTMLMetaProcessor.java"/>
<codefragment>
<![CDATA[
public class HTMLMetaProcessor {

  /**
   * Utility class with indicators for the robots directives "noindex" and
   * "nofollow", and HTTP-EQUIV/no-cache
   */

  /**
   * Sets the indicators in <code>robotsMeta</code> to appropriate values, based
   * on any META tags found under the given <code>node</code>.
   */
  public static final void getMetaTags(HTMLMetaTags metaTags, Node node,
      URL currURL) {

    metaTags.reset();
    getMetaTagsHelper(metaTags, node, currURL);
  }

  private static final void getMetaTagsHelper(HTMLMetaTags metaTags, Node node,
      URL currURL) {

    if (node.getNodeType() == Node.ELEMENT_NODE) {

      if ("body".equalsIgnoreCase(node.getNodeName())) {
        // META tags should not be under body
        return;
      }

      if ("meta".equalsIgnoreCase(node.getNodeName())) {
        NamedNodeMap attrs = node.getAttributes();
        Node nameNode = null;
        Node equivNode = null;
        Node contentNode = null;
        // Retrieves name, http-equiv and content attribues
        for (int i = 0; i < attrs.getLength(); i++) {
          Node attr = attrs.item(i);
          String attrName = attr.getNodeName().toLowerCase();
          if (attrName.equals("name")) {
            nameNode = attr;
          } else if (attrName.equals("http-equiv")) {
            equivNode = attr;
          } else if (attrName.equals("content")) {
            contentNode = attr;
          }
        }

        if (nameNode != null) {
          if (contentNode != null) {
            String name = nameNode.getNodeValue().toLowerCase();
            metaTags.getGeneralTags().add(name, contentNode.getNodeValue());
            if ("robots".equals(name)) {

              if (contentNode != null) {
                String directives = contentNode.getNodeValue().toLowerCase();
                int index = directives.indexOf("none");

                if (index >= 0) {
                  metaTags.setNoIndex();
                  metaTags.setNoFollow();
                }

                index = directives.indexOf("all");
                if (index >= 0) {
                  // do nothing...
                }

                index = directives.indexOf("noindex");
                if (index >= 0) {
                  metaTags.setNoIndex();
                }

                index = directives.indexOf("nofollow");
                if (index >= 0) {
                  metaTags.setNoFollow();
                }

                index = directives.indexOf("noarchive");
                if (index >= 0) {
                  metaTags.setNoCache();
                }
              }

            } // end if (name == robots)
          }
        }

        if (equivNode != null) {
          if (contentNode != null) {
            String name = equivNode.getNodeValue().toLowerCase();
            String content = contentNode.getNodeValue();
            metaTags.getHttpEquivTags().setProperty(name, content);
            if ("pragma".equals(name)) {
              content = content.toLowerCase();
              int index = content.indexOf("no-cache");
              if (index >= 0)
                metaTags.setNoCache();
            } else if ("refresh".equals(name)) {
              int idx = content.indexOf(';');
              String time = null;
              if (idx == -1) { // just the refresh time
                time = content;
              } else
                time = content.substring(0, idx);
              try {
                metaTags.setRefreshTime(Integer.parseInt(time));
                // skip this if we couldn't parse the time
                metaTags.setRefresh(true);
              } catch (Exception e) {
                ;
              }
              URL refreshUrl = null;
              if (metaTags.getRefresh() && idx != -1) { // set the URL
                idx = content.toLowerCase().indexOf("url=");
                if (idx == -1) { // assume a mis-formatted entry with just the
                                 // url
                  idx = content.indexOf(';') + 1;
                } else
                  idx += 4;
                if (idx != -1) {
                  String url = content.substring(idx);
                  try {
                    refreshUrl = new URL(url);
                  } catch (Exception e) {
                    // XXX according to the spec, this has to be an absolute
                    // XXX url. However, many websites use relative URLs and
                    // XXX expect browsers to handle that.
                    // XXX Unfortunately, in some cases this may create a
                    // XXX infinitely recursive paths (a crawler trap)...
                    // if (!url.startsWith("/")) url = "/" + url;
                    try {
                      refreshUrl = new URL(currURL, url);
                    } catch (Exception e1) {
                      refreshUrl = null;
                    }
                  }
                }
              }
              if (metaTags.getRefresh()) {
                if (refreshUrl == null) {
                  // apparently only refresh time was present. set the URL
                  // to the same URL.
                  refreshUrl = currURL;
                }
                metaTags.setRefreshHref(refreshUrl);
              }
            }
          }
        }

      } else if ("base".equalsIgnoreCase(node.getNodeName())) {
        NamedNodeMap attrs = node.getAttributes();
        Node hrefNode = attrs.getNamedItem("href");

        if (hrefNode != null) {
          String urlString = hrefNode.getNodeValue();

          URL url = null;
          try {
            if (currURL == null)
              url = new URL(urlString);
            else
              url = new URL(currURL, urlString);
          } catch (Exception e) {
            ;
          }

          if (url != null)
            metaTags.setBaseHref(url);
        }

      }

    }

    NodeList children = node.getChildNodes();
    if (children != null) {
      int len = children.getLength();
      for (int i = 0; i < len; i++) {
        getMetaTagsHelper(metaTags, children.item(i), currURL);
      }
    }
  }

}
]]>
</codefragment>
</duplication>
<duplication lines="418" tokens="712">
<file line="349" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\DOMBuilder.java"/>
<file line="349" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\DOMBuilder.java"/>
<codefragment>
<![CDATA[
    m_currentNode = m_elemStack.isEmpty() ? null : (Node) m_elemStack.peek();
  }

  /**
   * Set an ID string to node association in the ID table.
   * 
   * @param id
   *          The ID string.
   * @param elem
   *          The associated ID.
   */
  public void setIDAttribute(String id, Element elem) {

    // Do nothing. This method is meant to be overiden.
  }

  /**
   * Receive notification of character data.
   * 
   * <p>
   * The Parser will call this method to report each chunk of character data.
   * SAX parsers may return all contiguous character data in a single chunk, or
   * they may split it into several chunks; however, all of the characters in
   * any single event must come from the same external entity, so that the
   * Locator provides useful information.
   * </p>
   * 
   * <p>
   * The application must not attempt to read from the array outside of the
   * specified range.
   * </p>
   * 
   * <p>
   * Note that some parsers will report whitespace using the
   * ignorableWhitespace() method rather than this one (validating parsers must
   * do so).
   * </p>
   * 
   * @param ch
   *          The characters from the XML document.
   * @param start
   *          The start position in the array.
   * @param length
   *          The number of characters to read from the array.
   * @see #ignorableWhitespace
   * @see org.xml.sax.Locator
   */
  public void characters(char ch[], int start, int length)
      throws org.xml.sax.SAXException {
    if (isOutsideDocElem()
        && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return; // avoid DOM006 Hierarchy request error

    if (m_inCData) {
      cdata(ch, start, length);

      return;
    }

    String s = new String(ch, start, length);
    Node childNode;
    childNode = m_currentNode != null ? m_currentNode.getLastChild() : null;
    if (childNode != null && childNode.getNodeType() == Node.TEXT_NODE) {
      ((Text) childNode).appendData(s);
    } else {
      Text text = m_doc.createTextNode(s);
      append(text);
    }
  }

  /**
   * If available, when the disable-output-escaping attribute is used, output
   * raw text without escaping. A PI will be inserted in front of the node with
   * the name "lotusxsl-next-is-raw" and a value of "formatter-to-dom".
   * 
   * @param ch
   *          Array containing the characters
   * @param start
   *          Index to start of characters in the array
   * @param length
   *          Number of characters in the array
   */
  public void charactersRaw(char ch[], int start, int length)
      throws org.xml.sax.SAXException {
    if (isOutsideDocElem()
        && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return; // avoid DOM006 Hierarchy request error

    String s = new String(ch, start, length);

    append(m_doc.createProcessingInstruction("xslt-next-is-raw",
        "formatter-to-dom"));
    append(m_doc.createTextNode(s));
  }

  /**
   * Report the beginning of an entity.
   * 
   * The start and end of the document entity are not reported. The start and
   * end of the external DTD subset are reported using the pseudo-name "[dtd]".
   * All other events must be properly nested within start/end entity events.
   * 
   * @param name
   *          The name of the entity. If it is a parameter entity, the name will
   *          begin with '%'.
   * @see #endEntity
   * @see org.xml.sax.ext.DeclHandler#internalEntityDecl
   * @see org.xml.sax.ext.DeclHandler#externalEntityDecl
   */
  public void startEntity(String name) throws org.xml.sax.SAXException {

    // Almost certainly the wrong behavior...
    // entityReference(name);
  }

  /**
   * Report the end of an entity.
   * 
   * @param name
   *          The name of the entity that is ending.
   * @see #startEntity
   */
  public void endEntity(String name) throws org.xml.sax.SAXException {
  }

  /**
   * Receive notivication of a entityReference.
   * 
   * @param name
   *          name of the entity reference
   */
  public void entityReference(String name) throws org.xml.sax.SAXException {
    append(m_doc.createEntityReference(name));
  }

  /**
   * Receive notification of ignorable whitespace in element content.
   * 
   * <p>
   * Validating Parsers must use this method to report each chunk of ignorable
   * whitespace (see the W3C XML 1.0 recommendation, section 2.10):
   * non-validating parsers may also use this method if they are capable of
   * parsing and using content models.
   * </p>
   * 
   * <p>
   * SAX parsers may return all contiguous whitespace in a single chunk, or they
   * may split it into several chunks; however, all of the characters in any
   * single event must come from the same external entity, so that the Locator
   * provides useful information.
   * </p>
   * 
   * <p>
   * The application must not attempt to read from the array outside of the
   * specified range.
   * </p>
   * 
   * @param ch
   *          The characters from the XML document.
   * @param start
   *          The start position in the array.
   * @param length
   *          The number of characters to read from the array.
   * @see #characters
   */
  public void ignorableWhitespace(char ch[], int start, int length)
      throws org.xml.sax.SAXException {
    if (isOutsideDocElem())
      return; // avoid DOM006 Hierarchy request error

    String s = new String(ch, start, length);

    append(m_doc.createTextNode(s));
  }

  /**
   * Tell if the current node is outside the document element.
   * 
   * @return true if the current node is outside the document element.
   */
  private boolean isOutsideDocElem() {
    return (null == m_docFrag)
        && m_elemStack.size() == 0
        && (null == m_currentNode || m_currentNode.getNodeType() == Node.DOCUMENT_NODE);
  }

  /**
   * Receive notification of a processing instruction.
   * 
   * <p>
   * The Parser will invoke this method once for each processing instruction
   * found: note that processing instructions may occur before or after the main
   * document element.
   * </p>
   * 
   * <p>
   * A SAX parser should never report an XML declaration (XML 1.0, section 2.8)
   * or a text declaration (XML 1.0, section 4.3.1) using this method.
   * </p>
   * 
   * @param target
   *          The processing instruction target.
   * @param data
   *          The processing instruction data, or null if none was supplied.
   */
  public void processingInstruction(String target, String data)
      throws org.xml.sax.SAXException {
    append(m_doc.createProcessingInstruction(target, data));
  }

  /**
   * Report an XML comment anywhere in the document.
   * 
   * This callback will be used for comments inside or outside the document
   * element, including comments in the external DTD subset (if read).
   * 
   * @param ch
   *          An array holding the characters in the comment.
   * @param start
   *          The starting position in the array.
   * @param length
   *          The number of characters to use from the array.
   */
  public void comment(char ch[], int start, int length)
      throws org.xml.sax.SAXException {
    // tagsoup sometimes submits invalid values here
    if (ch == null || start < 0 || length >= (ch.length - start) || length < 0)
      return;
    append(m_doc.createComment(new String(ch, start, length)));
  }

  /** Flag indicating that we are processing a CData section */
  protected boolean m_inCData = false;

  /**
   * Report the start of a CDATA section.
   * 
   * @see #endCDATA
   */
  public void startCDATA() throws org.xml.sax.SAXException {
    m_inCData = true;
    append(m_doc.createCDATASection(""));
  }

  /**
   * Report the end of a CDATA section.
   * 
   * @see #startCDATA
   */
  public void endCDATA() throws org.xml.sax.SAXException {
    m_inCData = false;
  }

  /**
   * Receive notification of cdata.
   * 
   * <p>
   * The Parser will call this method to report each chunk of character data.
   * SAX parsers may return all contiguous character data in a single chunk, or
   * they may split it into several chunks; however, all of the characters in
   * any single event must come from the same external entity, so that the
   * Locator provides useful information.
   * </p>
   * 
   * <p>
   * The application must not attempt to read from the array outside of the
   * specified range.
   * </p>
   * 
   * <p>
   * Note that some parsers will report whitespace using the
   * ignorableWhitespace() method rather than this one (validating parsers must
   * do so).
   * </p>
   * 
   * @param ch
   *          The characters from the XML document.
   * @param start
   *          The start position in the array.
   * @param length
   *          The number of characters to read from the array.
   * @see #ignorableWhitespace
   * @see org.xml.sax.Locator
   */
  public void cdata(char ch[], int start, int length)
      throws org.xml.sax.SAXException {
    if (isOutsideDocElem()
        && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return; // avoid DOM006 Hierarchy request error

    String s = new String(ch, start, length);

    // XXX ab@apache.org: modified from the original, to accomodate TagSoup.
    Node n = m_currentNode.getLastChild();
    if (n instanceof CDATASection)
      ((CDATASection) n).appendData(s);
    else if (n instanceof Comment)
      ((Comment) n).appendData(s);
  }

  /**
   * Report the start of DTD declarations, if any.
   * 
   * Any declarations are assumed to be in the internal subset unless otherwise
   * indicated.
   * 
   * @param name
   *          The document type name.
   * @param publicId
   *          The declared public identifier for the external DTD subset, or
   *          null if none was declared.
   * @param systemId
   *          The declared system identifier for the external DTD subset, or
   *          null if none was declared.
   * @see #endDTD
   * @see #startEntity
   */
  public void startDTD(String name, String publicId, String systemId)
      throws org.xml.sax.SAXException {

    // Do nothing for now.
  }

  /**
   * Report the end of DTD declarations.
   * 
   * @see #startDTD
   */
  public void endDTD() throws org.xml.sax.SAXException {

    // Do nothing for now.
  }

  /**
   * Begin the scope of a prefix-URI Namespace mapping.
   * 
   * <p>
   * The information from this event is not necessary for normal Namespace
   * processing: the SAX XML reader will automatically replace prefixes for
   * element and attribute names when the http://xml.org/sax/features/namespaces
   * feature is true (the default).
   * </p>
   * 
   * <p>
   * There are cases, however, when applications need to use prefixes in
   * character data or in attribute values, where they cannot safely be expanded
   * automatically; the start/endPrefixMapping event supplies the information to
   * the application to expand prefixes in those contexts itself, if necessary.
   * </p>
   * 
   * <p>
   * Note that start/endPrefixMapping events are not guaranteed to be properly
   * nested relative to each-other: all startPrefixMapping events will occur
   * before the corresponding startElement event, and all endPrefixMapping
   * events will occur after the corresponding endElement event, but their order
   * is not guaranteed.
   * </p>
   * 
   * @param prefix
   *          The Namespace prefix being declared.
   * @param uri
   *          The Namespace URI the prefix is mapped to.
   * @see #endPrefixMapping
   * @see #startElement
   */
  public void startPrefixMapping(String prefix, String uri)
      throws org.xml.sax.SAXException {

    /*
     * // Not sure if this is needed or wanted // Also, it fails in the stree.
     * if((null != m_currentNode) && (m_currentNode.getNodeType() ==
     * Node.ELEMENT_NODE)) { String qname; if(((null != prefix) &&
     * (prefix.length() == 0)) || (null == prefix)) qname = "xmlns"; else qname
     * = "xmlns:"+prefix;
     * 
     * Element elem = (Element)m_currentNode; String val =
     * elem.getAttribute(qname); // Obsolete, should be DOM2...? if(val == null)
     * { elem.setAttributeNS("http://www.w3.org/XML/1998/namespace", qname,
     * uri); } }
     */
  }

  /**
   * End the scope of a prefix-URI mapping.
   * 
   * <p>
   * See startPrefixMapping for details. This event will always occur after the
   * corresponding endElement event, but the order of endPrefixMapping events is
   * not otherwise guaranteed.
   * </p>
   * 
   * @param prefix
   *          The prefix that was being mapping.
   * @see #startPrefixMapping
   * @see #endElement
   */
  public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException {
  }

  /**
   * Receive notification of a skipped entity.
   * 
   * <p>
   * The Parser will invoke this method once for each entity skipped.
   * Non-validating processors may skip entities if they have not seen the
   * declarations (because, for example, the entity was declared in an external
   * DTD subset). All processors may skip external entities, depending on the
   * values of the http://xml.org/sax/features/external-general-entities and the
   * http://xml.org/sax/features/external-parameter-entities properties.
   * </p>
   * 
   * @param name
   *          The name of the skipped entity. If it is a parameter entity, the
   *          name will begin with '%'.
   */
  public void skippedEntity(String name) throws org.xml.sax.SAXException {
  }
}
]]>
</codefragment>
</duplication>
<duplication lines="125" tokens="632">
<file line="200" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\DOMContentUtils.java"/>
<file line="201" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\DOMContentUtils.java"/>
<codefragment>
<![CDATA[
  URL getBase(Node node) {

    NodeWalker walker = new NodeWalker(node);

    while (walker.hasNext()) {

      Node currentNode = walker.nextNode();
      String nodeName = currentNode.getNodeName();
      short nodeType = currentNode.getNodeType();

      // is this node a BASE tag?
      if (nodeType == Node.ELEMENT_NODE) {

        if ("body".equalsIgnoreCase(nodeName)) { // stop after HEAD
          return null;
        }

        if ("base".equalsIgnoreCase(nodeName)) {
          NamedNodeMap attrs = currentNode.getAttributes();
          for (int i = 0; i < attrs.getLength(); i++) {
            Node attr = attrs.item(i);
            if ("href".equalsIgnoreCase(attr.getNodeName())) {
              try {
                return new URL(attr.getNodeValue());
              } catch (MalformedURLException e) {
              }
            }
          }
        }
      }
    }

    // no.
    return null;
  }

  private boolean hasOnlyWhiteSpace(Node node) {
    String val = node.getNodeValue();
    for (int i = 0; i < val.length(); i++) {
      if (!Character.isWhitespace(val.charAt(i)))
        return false;
    }
    return true;
  }

  // this only covers a few cases of empty links that are symptomatic
  // of nekohtml's DOM-fixup process...
  private boolean shouldThrowAwayLink(Node node, NodeList children,
      int childLen, LinkParams params) {
    if (childLen == 0) {
      // this has no inner structure
      if (params.childLen == 0)
        return false;
      else
        return true;
    } else if ((childLen == 1)
        && (children.item(0).getNodeType() == Node.ELEMENT_NODE)
        && (params.elName.equalsIgnoreCase(children.item(0).getNodeName()))) {
      // single nested link
      return true;

    } else if (childLen == 2) {

      Node c0 = children.item(0);
      Node c1 = children.item(1);

      if ((c0.getNodeType() == Node.ELEMENT_NODE)
          && (params.elName.equalsIgnoreCase(c0.getNodeName()))
          && (c1.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c1)) {
        // single link followed by whitespace node
        return true;
      }

      if ((c1.getNodeType() == Node.ELEMENT_NODE)
          && (params.elName.equalsIgnoreCase(c1.getNodeName()))
          && (c0.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c0)) {
        // whitespace node followed by single link
        return true;
      }

    } else if (childLen == 3) {
      Node c0 = children.item(0);
      Node c1 = children.item(1);
      Node c2 = children.item(2);

      if ((c1.getNodeType() == Node.ELEMENT_NODE)
          && (params.elName.equalsIgnoreCase(c1.getNodeName()))
          && (c0.getNodeType() == Node.TEXT_NODE)
          && (c2.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c0)
          && hasOnlyWhiteSpace(c2)) {
        // single link surrounded by whitespace nodes
        return true;
      }
    }

    return false;
  }

  /**
   * This method finds all anchors below the supplied DOM <code>node</code>, and
   * creates appropriate {@link Outlink} records for each (relative to the
   * supplied <code>base</code> URL), and adds them to the <code>outlinks</code>
   * {@link ArrayList}.
   * 
   * <p>
   * 
   * Links without inner structure (tags, text, etc) are discarded, as are links
   * which contain only single nested links and empty text nodes (this is a
   * common DOM-fixup artifact, at least with nekohtml).
   */
  public void getOutlinks(URL base, ArrayList<Outlink> outlinks, Node node) {

    NodeWalker walker = new NodeWalker(node);
    while (walker.hasNext()) {

      Node currentNode = walker.nextNode();
      String nodeName = currentNode.getNodeName();
      short nodeType = currentNode.getNodeType();
      NodeList children = currentNode.getChildNodes();
      int childLen = (children != null) ? children.getLength() : 0;

      if (nodeType == Node.ELEMENT_NODE) {

        nodeName = nodeName.toLowerCase();
        LinkParams params = (LinkParams) linkParams.get(nodeName);
]]>
</codefragment>
</duplication>
<duplication lines="226" tokens="473">
<file line="124" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\DOMBuilder.java"/>
<file line="124" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\DOMBuilder.java"/>
<codefragment>
<![CDATA[
  java.io.Writer getWriter() {
    return null;
  }

  /**
   * Append a node to the current container.
   * 
   * @param newNode
   *          New node to append
   */
  protected void append(Node newNode) throws org.xml.sax.SAXException {

    Node currentNode = m_currentNode;

    if (null != currentNode) {
      currentNode.appendChild(newNode);

      // System.out.println(newNode.getNodeName());
    } else if (null != m_docFrag) {
      m_docFrag.appendChild(newNode);
    } else {
      boolean ok = true;
      short type = newNode.getNodeType();

      if (type == Node.TEXT_NODE) {
        String data = newNode.getNodeValue();

        if ((null != data) && (data.trim().length() > 0)) {
          throw new org.xml.sax.SAXException(
              "Warning: can't output text before document element!  Ignoring...");
        }

        ok = false;
      } else if (type == Node.ELEMENT_NODE) {
        if (m_doc.getDocumentElement() != null) {
          throw new org.xml.sax.SAXException(
              "Can't have more than one root on a DOM!");
        }
      }

      if (ok)
        m_doc.appendChild(newNode);
    }
  }

  /**
   * Receive an object for locating the origin of SAX document events.
   * 
   * <p>
   * SAX parsers are strongly encouraged (though not absolutely required) to
   * supply a locator: if it does so, it must supply the locator to the
   * application by invoking this method before invoking any of the other
   * methods in the ContentHandler interface.
   * </p>
   * 
   * <p>
   * The locator allows the application to determine the end position of any
   * document-related event, even if the parser is not reporting an error.
   * Typically, the application will use this information for reporting its own
   * errors (such as character content that does not match an application's
   * business rules). The information returned by the locator is probably not
   * sufficient for use with a search engine.
   * </p>
   * 
   * <p>
   * Note that the locator will return correct information only during the
   * invocation of the events in this interface. The application should not
   * attempt to use it at any other time.
   * </p>
   * 
   * @param locator
   *          An object that can return the location of any SAX document event.
   * @see org.xml.sax.Locator
   */
  public void setDocumentLocator(Locator locator) {

    // No action for the moment.
  }

  /**
   * Receive notification of the beginning of a document.
   * 
   * <p>
   * The SAX parser will invoke this method only once, before any other methods
   * in this interface or in DTDHandler (except for setDocumentLocator).
   * </p>
   */
  public void startDocument() throws org.xml.sax.SAXException {

    // No action for the moment.
  }

  /**
   * Receive notification of the end of a document.
   * 
   * <p>
   * The SAX parser will invoke this method only once, and it will be the last
   * method invoked during the parse. The parser shall not invoke this method
   * until it has either abandoned parsing (because of an unrecoverable error)
   * or reached the end of input.
   * </p>
   */
  public void endDocument() throws org.xml.sax.SAXException {

    // No action for the moment.
  }

  /**
   * Receive notification of the beginning of an element.
   * 
   * <p>
   * The Parser will invoke this method at the beginning of every element in the
   * XML document; there will be a corresponding endElement() event for every
   * startElement() event (even when the element is empty). All of the element's
   * content will be reported, in order, before the corresponding endElement()
   * event.
   * </p>
   * 
   * <p>
   * If the element name has a namespace prefix, the prefix will still be
   * attached. Note that the attribute list provided will contain only
   * attributes with explicit values (specified or defaulted): #IMPLIED
   * attributes will be omitted.
   * </p>
   * 
   * 
   * @param ns
   *          The namespace of the node
   * @param localName
   *          The local part of the qualified name
   * @param name
   *          The element name.
   * @param atts
   *          The attributes attached to the element, if any.
   * @see #endElement
   * @see org.xml.sax.Attributes
   */
  public void startElement(String ns, String localName, String name,
      Attributes atts) throws org.xml.sax.SAXException {

    Element elem;

    // Note that the namespace-aware call must be used to correctly
    // construct a Level 2 DOM, even for non-namespaced nodes.
    if ((null == ns) || (ns.length() == 0))
      elem = m_doc.createElementNS(null, name);
    else
      elem = m_doc.createElementNS(ns, name);

    append(elem);

    try {
      int nAtts = atts.getLength();

      if (0 != nAtts) {
        for (int i = 0; i < nAtts; i++) {

          // System.out.println("type " + atts.getType(i) + " name " +
          // atts.getLocalName(i) );
          // First handle a possible ID attribute
          if (atts.getType(i).equalsIgnoreCase("ID"))
            setIDAttribute(atts.getValue(i), elem);

          String attrNS = atts.getURI(i);

          if ("".equals(attrNS))
            attrNS = null; // DOM represents no-namespace as null

          // System.out.println("attrNS: "+attrNS+", localName: "+atts.getQName(i)
          // +", qname: "+atts.getQName(i)+", value: "+atts.getValue(i));
          // Crimson won't let us set an xmlns: attribute on the DOM.
          String attrQName = atts.getQName(i);

          // In SAX, xmlns: attributes have an empty namespace, while in DOM
          // they should have the xmlns namespace
          if (attrQName.startsWith("xmlns:"))
            attrNS = "http://www.w3.org/2000/xmlns/";

          // ALWAYS use the DOM Level 2 call!
          elem.setAttributeNS(attrNS, attrQName, atts.getValue(i));
        }
      }

      // append(elem);

      m_elemStack.push(elem);

      m_currentNode = elem;

      // append(elem);
    } catch (java.lang.Exception de) {
      // de.printStackTrace();
      throw new org.xml.sax.SAXException(de);
    }

  }

  /**
   * 
   * 
   * 
   * Receive notification of the end of an element.
   * 
   * <p>
   * The SAX parser will invoke this method at the end of every element in the
   * XML document; there will be a corresponding startElement() event for every
   * endElement() event (even when the element is empty).
   * </p>
   * 
   * <p>
   * If the element name has a namespace prefix, the prefix will still be
   * attached to the name.
   * </p>
   * 
   * 
   * @param ns
   *          the namespace of the element
   * @param localName
   *          The local part of the qualified name of the element
   * @param name
   *          The element name
   */
  public void endElement(String ns, String localName, String name)
      throws org.xml.sax.SAXException {
    m_elemStack.pop();
    m_currentNode = m_elemStack.isEmpty() ? null : (Node) m_elemStack.peek();
]]>
</codefragment>
</duplication>
<duplication lines="42" tokens="319">
<file line="47" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\DOMContentUtils.java"/>
<file line="48" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\DOMContentUtils.java"/>
<codefragment>
<![CDATA[
    private LinkParams(String elName, String attrName, int childLen) {
      this.elName = elName;
      this.attrName = attrName;
      this.childLen = childLen;
    }

    public String toString() {
      return "LP[el=" + elName + ",attr=" + attrName + ",len=" + childLen + "]";
    }
  }

  private HashMap<String, LinkParams> linkParams = new HashMap<String, LinkParams>();

  public DOMContentUtils(Configuration conf) {
    setConf(conf);
  }

  public void setConf(Configuration conf) {
    // forceTags is used to override configurable tag ignoring, later on
    Collection<String> forceTags = new ArrayList<String>(1);

    linkParams.clear();
    linkParams.put("a", new LinkParams("a", "href", 1));
    linkParams.put("area", new LinkParams("area", "href", 0));
    if (conf.getBoolean("parser.html.form.use_action", true)) {
      linkParams.put("form", new LinkParams("form", "action", 1));
      if (conf.get("parser.html.form.use_action") != null)
        forceTags.add("form");
    }
    linkParams.put("frame", new LinkParams("frame", "src", 0));
    linkParams.put("iframe", new LinkParams("iframe", "src", 0));
    linkParams.put("script", new LinkParams("script", "src", 0));
    linkParams.put("link", new LinkParams("link", "href", 0));
    linkParams.put("img", new LinkParams("img", "src", 0));

    // remove unwanted link tags from the linkParams map
    String[] ignoreTags = conf.getStrings("parser.html.outlinks.ignore_tags");
    for (int i = 0; ignoreTags != null && i < ignoreTags.length; i++) {
      if (!forceTags.contains(ignoreTags[i]))
        linkParams.remove(ignoreTags[i]);
    }
  }
]]>
</codefragment>
</duplication>
<duplication lines="54" tokens="256">
<file line="16" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\indexer\solr\SolrUtils.java"/>
<file line="15" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\indexer-solr\src\java\org\apache\nutch\indexwriter\solr\SolrUtils.java"/>
<codefragment>
<![CDATA[
public class SolrUtils {

  public static Logger LOG = LoggerFactory.getLogger(SolrUtils.class);

  public static HttpSolrServer getHttpSolrServer(Configuration job)
      throws MalformedURLException {
    DefaultHttpClient client = new DefaultHttpClient();

    // Check for username/password
    if (job.getBoolean(SolrConstants.USE_AUTH, false)) {
      String username = job.get(SolrConstants.USERNAME);

      LOG.info("Authenticating as: " + username);

      AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT,
          AuthScope.ANY_REALM, AuthScope.ANY_SCHEME);

      client.getCredentialsProvider().setCredentials(
          scope,
          new UsernamePasswordCredentials(username, job
              .get(SolrConstants.PASSWORD)));

      HttpParams params = client.getParams();
      HttpClientParams.setAuthenticating(params, true);

      client.setParams(params);
    }

    return new HttpSolrServer(job.get(SolrConstants.SERVER_URL), client);
  }

  public static String stripNonCharCodepoints(String input) {
    StringBuilder retval = new StringBuilder();
    char ch;

    for (int i = 0; i < input.length(); i++) {
      ch = input.charAt(i);

      // Strip all non-characters
      // http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[:Noncharacter_Code_Point=True:]
      // and non-printable control characters except tabulator, new line and
      // carriage return
      if (ch % 0x10000 != 0xffff && // 0xffff - 0x10ffff range step 0x10000
          ch % 0x10000 != 0xfffe && // 0xfffe - 0x10fffe range
          (ch <= 0xfdd0 || ch >= 0xfdef) && // 0xfdd0 - 0xfdef
          (ch > 0x1F || ch == 0x9 || ch == 0xa || ch == 0xd)) {

        retval.append(ch);
      }
    }

    return retval.toString();
  }
}
]]>
</codefragment>
</duplication>
<duplication lines="78" tokens="231">
<file line="71" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\test\org\apache\nutch\parse\html\TestDOMContentUtils.java"/>
<file line="85" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\DOMContentUtilsTest.java"/>
<codefragment>
<![CDATA[
          + "<frame src=\"invalid.html\"/>" + "</frame>"
          + "<frame src=\"right.html\">" + "</frame>" + "</frameset>"
          + "</frameset>" + "</body></html>"),
      // 5.
      // test <area> and <iframe> link extraction + url normalization
      new String(
          "<html><head><title> my title </title>"
              + "</head><body>"
              + "<img src=\"logo.gif\" usemap=\"#green\" border=\"0\">"
              + "<map name=\"green\">"
              + "<area shape=\"polygon\" coords=\"19,44,45,11,87\" href=\"../index.html\">"
              + "<area shape=\"rect\" coords=\"128,132,241,179\" href=\"#bottom\">"
              + "<area shape=\"circle\" coords=\"68,211,35\" href=\"../bot.html\">"
              + "</map>" + "<a name=\"bottom\"/><h1> the bottom </h1> "
              + "<iframe src=\"../docs/index.html\"/>" + "</body></html>"),
      // 6.
      // test whitespace processing for plain text extraction
      new String(
          "<html><head>\n <title> my\t\n  title\r\n </title>\n"
              + " </head>\n"
              + " <body>\n"
              + "    <h1> Whitespace\ttest  </h1> \n"
              + "\t<a href=\"../index.html\">\n  \twhitespace  test\r\n\t</a>  \t\n"
              + "    <p> This is<span> a whitespace<span></span> test</span>. Newlines\n"
              + "should appear as space too.</p><p>Tabs\tare spaces too.\n</p>"
              + "    This\t<b>is a</b> break -&gt;<br>and the line after<i> break</i>.<br>\n"
              + "<table>"
              + "    <tr><td>one</td><td>two</td><td>three</td></tr>\n"
              + "    <tr><td>space here </td><td> space there</td><td>no space</td></tr>"
              + "\t<tr><td>one\r\ntwo</td><td>two\tthree</td><td>three\r\tfour</td></tr>\n"
              + "</table>put some text here<Br>and there."
              + "<h2>End\tthis\rmadness\n!</h2>\r\n"
              + "         .        .        .         ." + "</body>  </html>"),
      // 7.
      // test that <a rel=nofollow> links are not returned
      new String("<html><head></head><body>"
          + "<a href=\"http://www.nutch.org\" rel=\"nofollow\"> ignore </a>"
          + "<a rel=\"nofollow\" href=\"http://www.nutch.org\"> ignore </a>"
          + "</body></html>"),
      // 8.
      // test that POST form actions are skipped
      new String("<html><head></head><body>"
          + "<form method='POST' action='/search.jsp'><input type=text>"
          + "<input type=submit><p>test1</p></form>"
          + "<form method='GET' action='/dummy.jsp'><input type=text>"
          + "<input type=submit><p>test2</p></form></body></html>"),
      // 9.
      // test that all form actions are skipped
      new String("<html><head></head><body>"
          + "<form method='POST' action='/search.jsp'><input type=text>"
          + "<input type=submit><p>test1</p></form>"
          + "<form method='GET' action='/dummy.jsp'><input type=text>"
          + "<input type=submit><p>test2</p></form></body></html>"),
      // 10.
      new String("<html><head><title> title </title>" + "</head><body>"
          + "<a href=\";x\">anchor1</a>" + "<a href=\"g;x\">anchor2</a>"
          + "<a href=\"g;x?y#s\">anchor3</a>" + "</body></html>"),
      // 11.
      new String("<html><head><title> title </title>" + "</head><body>"
          + "<a href=\"g\">anchor1</a>" + "<a href=\"g?y#s\">anchor2</a>"
          + "<a href=\"?y=1\">anchor3</a>" + "<a href=\"?y=1#s\">anchor4</a>"
          + "<a href=\"?y=1;somethingelse\">anchor5</a>" + "</body></html>"), };

  private static int SKIP = 9;

  private static String[] testBaseHrefs = { "http://www.nutch.org",
      "http://www.nutch.org/docs/foo.html", "http://www.nutch.org/docs/",
      "http://www.nutch.org/docs/", "http://www.nutch.org/frames/",
      "http://www.nutch.org/maps/", "http://www.nutch.org/whitespace/",
      "http://www.nutch.org//", "http://www.nutch.org/",
      "http://www.nutch.org/", "http://www.nutch.org/",
      "http://www.nutch.org/;something" };

  private static final DocumentFragment testDOMs[] = new DocumentFragment[testPages.length];

  private static URL[] testBaseHrefURLs = new URL[testPages.length];

  private static final String[] answerText = {
]]>
</codefragment>
</duplication>
<duplication lines="66" tokens="227">
<file line="512" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\Host.java"/>
<file line="2698" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\WebPage.java"/>
<codefragment>
<![CDATA[
        java.util.Map<java.lang.CharSequence, java.lang.CharSequence> value) {
      throw new java.lang.UnsupportedOperationException(
          "IsDirty is not supported on tombstones");
    }

    /**
     * Gets the value of the 'outlinks' field. Embedded hyperlinks which direct
     * outside of the current domain.
     */
    public java.util.Map<java.lang.CharSequence, java.lang.CharSequence> getOutlinks() {
      throw new java.lang.UnsupportedOperationException(
          "Get is not supported on tombstones");
    }

    /**
     * Sets the value of the 'outlinks' field. Embedded hyperlinks which direct
     * outside of the current domain. * @param value the value to set.
     */
    public void setOutlinks(
        java.util.Map<java.lang.CharSequence, java.lang.CharSequence> value) {
      throw new java.lang.UnsupportedOperationException(
          "Set is not supported on tombstones");
    }

    /**
     * Checks the dirty status of the 'outlinks' field. A field is dirty if it
     * represents a change that has not yet been written to the database.
     * Embedded hyperlinks which direct outside of the current domain. * @param
     * value the value to set.
     */
    public boolean isOutlinksDirty(
        java.util.Map<java.lang.CharSequence, java.lang.CharSequence> value) {
      throw new java.lang.UnsupportedOperationException(
          "IsDirty is not supported on tombstones");
    }

    /**
     * Gets the value of the 'inlinks' field. Embedded hyperlinks which link to
     * pages within the current domain.
     */
    public java.util.Map<java.lang.CharSequence, java.lang.CharSequence> getInlinks() {
      throw new java.lang.UnsupportedOperationException(
          "Get is not supported on tombstones");
    }

    /**
     * Sets the value of the 'inlinks' field. Embedded hyperlinks which link to
     * pages within the current domain. * @param value the value to set.
     */
    public void setInlinks(
        java.util.Map<java.lang.CharSequence, java.lang.CharSequence> value) {
      throw new java.lang.UnsupportedOperationException(
          "Set is not supported on tombstones");
    }

    /**
     * Checks the dirty status of the 'inlinks' field. A field is dirty if it
     * represents a change that has not yet been written to the database.
     * Embedded hyperlinks which link to pages within the current domain. * @param
     * value the value to set.
     */
    public boolean isInlinksDirty(
        java.util.Map<java.lang.CharSequence, java.lang.CharSequence> value) {
      throw new java.lang.UnsupportedOperationException(
          "IsDirty is not supported on tombstones");
    }
]]>
</codefragment>
</duplication>
<duplication lines="39" tokens="209">
<file line="328" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\DOMContentUtils.java"/>
<file line="329" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\DOMContentUtils.java"/>
<codefragment>
<![CDATA[
            StringBuffer linkText = new StringBuffer();
            getText(linkText, currentNode, true);

            NamedNodeMap attrs = currentNode.getAttributes();
            String target = null;
            boolean noFollow = false;
            boolean post = false;
            for (int i = 0; i < attrs.getLength(); i++) {
              Node attr = attrs.item(i);
              String attrName = attr.getNodeName();
              if (params.attrName.equalsIgnoreCase(attrName)) {
                target = attr.getNodeValue();
              } else if ("rel".equalsIgnoreCase(attrName)
                  && "nofollow".equalsIgnoreCase(attr.getNodeValue())) {
                noFollow = true;
              } else if ("method".equalsIgnoreCase(attrName)
                  && "post".equalsIgnoreCase(attr.getNodeValue())) {
                post = true;
              }
            }
            if (target != null && !noFollow && !post)
              try {

                URL url = URLUtil.resolveURL(base, target);
                outlinks.add(new Outlink(url.toString(), linkText.toString()
                    .trim()));
              } catch (MalformedURLException e) {
                // don't care
              }
          }
          // this should not have any children, skip them
          if (params.childLen == 0)
            continue;
        }
      }
    }
  }

}
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="209">
<file line="112" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\WebPage.java"/>
<file line="1203" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\WebPage.java"/>
<codefragment>
<![CDATA[
    private java.lang.CharSequence baseUrl;
    private int status;
    private long fetchTime;
    private long prevFetchTime;
    private int fetchInterval;
    private int retriesSinceFetch;
    private long modifiedTime;
    private long prevModifiedTime;
    private org.apache.nutch.storage.ProtocolStatus protocolStatus;
    private java.nio.ByteBuffer content;
    private java.lang.CharSequence contentType;
    private java.nio.ByteBuffer prevSignature;
    private java.nio.ByteBuffer signature;
    private java.lang.CharSequence title;
    private java.lang.CharSequence text;
    private org.apache.nutch.storage.ParseStatus parseStatus;
    private float score;
    private java.lang.CharSequence reprUrl;
    private java.util.Map<java.lang.CharSequence, java.lang.CharSequence> headers;
    private java.util.Map<java.lang.CharSequence, java.lang.CharSequence> outlinks;
    private java.util.Map<java.lang.CharSequence, java.lang.CharSequence> inlinks;
    private java.util.Map<java.lang.CharSequence, java.lang.CharSequence> markers;
    private java.util.Map<java.lang.CharSequence, java.nio.ByteBuffer> metadata;
    private java.lang.CharSequence batchId;
]]>
</codefragment>
</duplication>
<duplication lines="51" tokens="208">
<file line="124" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\DOMContentUtils.java"/>
<file line="125" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\DOMContentUtils.java"/>
<codefragment>
<![CDATA[
  private boolean getTextHelper(StringBuffer sb, Node node,
      boolean abortOnNestedAnchors, int anchorDepth) {
    boolean abort = false;
    NodeWalker walker = new NodeWalker(node);

    while (walker.hasNext()) {

      Node currentNode = walker.nextNode();
      String nodeName = currentNode.getNodeName();
      short nodeType = currentNode.getNodeType();

      if ("script".equalsIgnoreCase(nodeName)) {
        walker.skipChildren();
      }
      if ("style".equalsIgnoreCase(nodeName)) {
        walker.skipChildren();
      }
      if (abortOnNestedAnchors && "a".equalsIgnoreCase(nodeName)) {
        anchorDepth++;
        if (anchorDepth > 1) {
          abort = true;
          break;
        }
      }
      if (nodeType == Node.COMMENT_NODE) {
        walker.skipChildren();
      }
      if (nodeType == Node.TEXT_NODE) {
        // cleanup and trim the value
        String text = currentNode.getNodeValue();
        text = text.replaceAll("\\s+", " ");
        text = text.trim();
        if (text.length() > 0) {
          if (sb.length() > 0)
            sb.append(' ');
          sb.append(text);
        }
      }
    }

    return abort;
  }

  /**
   * This method takes a {@link StringBuffer} and a DOM {@link Node}, and will
   * append the content text found beneath the first <code>title</code> node to
   * the <code>StringBuffer</code>.
   * 
   * @return true if a title node was found, false otherwise
   */
  public boolean getTitle(StringBuffer sb, Node node) {
]]>
</codefragment>
</duplication>
<duplication lines="31" tokens="203">
<file line="49" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\HTMLMetaProcessor.java"/>
<file line="114" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-metatags\src\test\org\apache\nutch\parse\metatags\TestMetaTagsParser.java"/>
<codefragment>
<![CDATA[
  public static final void getMetaTagsHelper(HTMLMetaTags metaTags, Node node,
      URL currURL) {

    if (node.getNodeType() == Node.ELEMENT_NODE) {

      if ("body".equalsIgnoreCase(node.getNodeName())) {
        // META tags should not be under body
        return;
      }

      if ("meta".equalsIgnoreCase(node.getNodeName())) {
        NamedNodeMap attrs = node.getAttributes();
        Node nameNode = null;
        Node equivNode = null;
        Node contentNode = null;
        // Retrieves name, http-equiv and content attribues
        for (int i = 0; i < attrs.getLength(); i++) {
          Node attr = attrs.item(i);
          String attrName = attr.getNodeName().toLowerCase();
          if (attrName.equals("name")) {
            nameNode = attr;
          } else if (attrName.equals("http-equiv")) {
            equivNode = attr;
          } else if (attrName.equals("content")) {
            contentNode = attr;
          }
        }
        if (nameNode != null) {
          if (contentNode != null) {
            String name = nameNode.getNodeValue().toLowerCase();
            metaTags.getGeneralTags().add(name, contentNode.getNodeValue());
]]>
</codefragment>
</duplication>
<duplication lines="23" tokens="182">
<file line="56" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestPdfParser.java"/>
<file line="70" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestRSSParser.java"/>
<codefragment>
<![CDATA[
  @Test
  public void testIt() throws ProtocolException, ParseException, IOException {
    String urlString;
    Parse parse;

    Configuration conf = NutchConfiguration.create();
    MimeUtil mimeutil = new MimeUtil(conf);
    for (int i = 0; i < sampleFiles.length; i++) {
      urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];

      File file = new File(sampleDir + fileSeparator + sampleFiles[i]);
      byte[] bytes = new byte[(int) file.length()];
      DataInputStream in = new DataInputStream(new FileInputStream(file));
      in.readFully(bytes);
      in.close();

      WebPage page = WebPage.newBuilder().build();
      page.setBaseUrl(new Utf8(urlString));
      page.setContent(ByteBuffer.wrap(bytes));
      String mtype = mimeutil.getMimeType(file);
      page.setContentType(new Utf8(mtype));

      parse = new ParseUtil(conf).parse(urlString, page);
]]>
</codefragment>
</duplication>
<duplication lines="44" tokens="178">
<file line="36" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\api\model\request\SeedList.java"/>
<file line="61" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\webui\model\SeedList.java"/>
<codefragment>
<![CDATA[
  }

  public Collection<SeedUrl> getSeedUrls() {
    return seedUrls;
  }

  public void setSeedUrls(Collection<SeedUrl> seedUrls) {
    this.seedUrls = seedUrls;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    SeedList other = (SeedList) obj;
    if (id == null) {
      if (other.id != null)
        return false;
    } else if (!id.equals(other.id))
      return false;
    return true;
  }

}
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="176">
<file line="220" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\HtmlParser.java"/>
<file line="142" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\TikaParser.java"/>
<codefragment>
<![CDATA[
      StringBuffer sb = new StringBuffer();
      if (LOG.isTraceEnabled()) {
        LOG.trace("Getting text...");
      }
      utils.getText(sb, root); // extract text
      text = sb.toString();
      sb.setLength(0);
      if (LOG.isTraceEnabled()) {
        LOG.trace("Getting title...");
      }
      utils.getTitle(sb, root); // extract title
      title = sb.toString().trim();
    }

    if (!metaTags.getNoFollow()) { // okay to follow links
      ArrayList<Outlink> l = new ArrayList<Outlink>(); // extract outlinks
      URL baseTag = utils.getBase(root);
      if (LOG.isTraceEnabled()) {
        LOG.trace("Getting links...");
      }
      utils.getOutlinks(baseTag != null ? baseTag : base, l, root);
      outlinks = l.toArray(new Outlink[l.size()]);
      if (LOG.isTraceEnabled()) {
        LOG.trace("found " + outlinks.length + " outlinks in " + base);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="174">
<file line="222" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\test\org\apache\nutch\metadata\TestMetadata.java"/>
<file line="210" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\test\org\apache\nutch\metadata\TestSpellCheckedMetadata.java"/>
<codefragment>
<![CDATA[
    SpellCheckedMetadata meta2 = new SpellCheckedMetadata();
    assertFalse(meta1.equals(null));
    assertFalse(meta1.equals("String"));
    assertTrue(meta1.equals(meta2));
    meta1.add("name-one", "value-1.1");
    assertFalse(meta1.equals(meta2));
    meta2.add("name-one", "value-1.1");
    assertTrue(meta1.equals(meta2));
    meta1.add("name-one", "value-1.2");
    assertFalse(meta1.equals(meta2));
    meta2.add("name-one", "value-1.2");
    assertTrue(meta1.equals(meta2));
    meta1.add("name-two", "value-2.1");
    assertFalse(meta1.equals(meta2));
    meta2.add("name-two", "value-2.1");
    assertTrue(meta1.equals(meta2));
    meta1.add("name-two", "value-2.2");
    assertFalse(meta1.equals(meta2));
    meta2.add("name-two", "value-2.x");
    assertFalse(meta1.equals(meta2));
  }

  /** Test for <code>Writable</code> implementation. */
  @Test
  public void testWritable() {
]]>
</codefragment>
</duplication>
<duplication lines="31" tokens="172">
<file line="272" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\Host.java"/>
<file line="307" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\ParseStatus.java"/>
<file line="319" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\ProtocolStatus.java"/>
<file line="1170" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\WebPage.java"/>
<codefragment>
<![CDATA[
    return new org.apache.nutch.storage.WebPage.Builder(other);
  }

  private static java.nio.ByteBuffer deepCopyToReadOnlyBuffer(
      java.nio.ByteBuffer input) {
    java.nio.ByteBuffer copy = java.nio.ByteBuffer.allocate(input.capacity());
    int position = input.position();
    input.reset();
    int mark = input.position();
    int limit = input.limit();
    input.rewind();
    input.limit(input.capacity());
    copy.put(input);
    input.rewind();
    copy.rewind();
    input.position(mark);
    input.mark();
    copy.position(mark);
    copy.mark();
    input.position(position);
    copy.position(position);
    input.limit(limit);
    copy.limit(limit);
    return copy.asReadOnlyBuffer();
  }

  /**
   * RecordBuilder for WebPage instances.
   */
  public static class Builder extends
      org.apache.avro.specific.SpecificRecordBuilderBase<WebPage> implements
]]>
</codefragment>
</duplication>
<duplication lines="20" tokens="166">
<file line="50" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestImageMetadata.java"/>
<file line="59" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestPdfParser.java"/>
<codefragment>
<![CDATA[
    Parse parse;
    Configuration conf = NutchConfiguration.create();
    MimeUtil mimeutil = new MimeUtil(conf);

    for (int i = 0; i < sampleFiles.length; i++) {
      urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];

      File file = new File(sampleDir + fileSeparator + sampleFiles[i]);
      byte[] bytes = new byte[(int) file.length()];
      DataInputStream in = new DataInputStream(new FileInputStream(file));
      in.readFully(bytes);
      in.close();

      WebPage page = WebPage.newBuilder().build();
      page.setBaseUrl(new Utf8(urlString));
      page.setContent(ByteBuffer.wrap(bytes));
      String mtype = mimeutil.getMimeType(file);
      page.setContentType(new Utf8(mtype));

      parse = new ParseUtil(conf).parse(urlString, page);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="160">
<file line="194" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\test\org\apache\nutch\parse\html\TestDOMContentUtils.java"/>
<file line="226" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\DOMContentUtilsTest.java"/>
<codefragment>
<![CDATA[
    answerOutlinks = new Outlink[][] {
        // 0
        { new Outlink("http://www.nutch.org", "anchor"), },
        // 1
        { new Outlink("http://www.nutch.org/", "home"),
            new Outlink("http://www.nutch.org/docs/bot.html", "bots"), },
        // 2
        { new Outlink("http://www.nutch.org/", "separate this"),
            new Outlink("http://www.nutch.org/docs/ok", "from this"), },

        // 3
        { new Outlink("http://www.nutch.org/", "home"),
            new Outlink("http://www.nutch.org/docs/1", "1"),
            new Outlink("http://www.nutch.org/docs/2", "2"), },
        // 4
        { new Outlink("http://www.nutch.org/frames/top.html", ""),
            new Outlink("http://www.nutch.org/frames/left.html", ""),
            new Outlink("http://www.nutch.org/frames/invalid.html", ""),
            new Outlink("http://www.nutch.org/frames/right.html", ""), },
        // 5
        { new Outlink("http://www.nutch.org/maps/logo.gif", ""),
            new Outlink("http://www.nutch.org/index.html", ""),
            new Outlink("http://www.nutch.org/maps/#bottom", ""),
            new Outlink("http://www.nutch.org/bot.html", ""),
            new Outlink("http://www.nutch.org/docs/index.html", "") },
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="157">
<file line="133" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\test\org\apache\nutch\metadata\TestMetadata.java"/>
<file line="120" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\test\org\apache\nutch\metadata\TestSpellCheckedMetadata.java"/>
<codefragment>
<![CDATA[
    SpellCheckedMetadata meta = new SpellCheckedMetadata();
    Properties props = new Properties();

    meta.setAll(props);
    assertEquals(0, meta.size());

    props.setProperty("name-one", "value1.1");
    meta.setAll(props);
    assertEquals(1, meta.size());
    values = meta.getValues("name-one");
    assertEquals(1, values.length);
    assertEquals("value1.1", values[0]);

    props.setProperty("name-two", "value2.1");
    meta.setAll(props);
    assertEquals(2, meta.size());
    values = meta.getValues("name-one");
    assertEquals(1, values.length);
    assertEquals("value1.1", values[0]);
    values = meta.getValues("name-two");
    assertEquals(1, values.length);
    assertEquals("value2.1", values[0]);
  }

  /** Test for <code>get(String)</code> method. */
  @Test
  public void testGet() {
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="147">
<file line="199" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\test\org\apache\nutch\metadata\TestMetadata.java"/>
<file line="187" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\test\org\apache\nutch\metadata\TestSpellCheckedMetadata.java"/>
<codefragment>
<![CDATA[
    SpellCheckedMetadata meta = new SpellCheckedMetadata();
    meta.remove("name-one");
    assertEquals(0, meta.size());
    meta.add("name-one", "value-1.1");
    meta.add("name-one", "value-1.2");
    meta.add("name-two", "value-2.2");
    assertEquals(2, meta.size());
    assertNotNull(meta.get("name-one"));
    assertNotNull(meta.get("name-two"));
    meta.remove("name-one");
    assertEquals(1, meta.size());
    assertNull(meta.get("name-one"));
    assertNotNull(meta.get("name-two"));
    meta.remove("name-two");
    assertEquals(0, meta.size());
    assertNull(meta.get("name-one"));
    assertNull(meta.get("name-two"));
  }

  /** Test for <code>equals(Object)</code> method. */
  @Test
  public void testObject() {
]]>
</codefragment>
</duplication>
<duplication lines="29" tokens="139">
<file line="33" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\api\model\request\SeedUrl.java"/>
<file line="67" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\webui\model\SeedUrl.java"/>
<codefragment>
<![CDATA[
  public void setSeedList(SeedList seedList) {
    this.seedList = seedList;
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    SeedUrl other = (SeedUrl) obj;
    if (id == null) {
      if (other.id != null)
        return false;
    } else if (!id.equals(other.id))
      return false;
    return true;
  }
}
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="137">
<file line="126" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\urlfilter-prefix\src\java\org\apache\nutch\urlfilter\prefix\PrefixURLFilter.java"/>
<file line="262" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\urlfilter-suffix\src\java\org\apache\nutch\urlfilter\suffix\SuffixURLFilter.java"/>
<codefragment>
<![CDATA[
    Extension[] extensions = PluginRepository.get(conf)
        .getExtensionPoint(URLFilter.class.getName()).getExtensions();
    for (int i = 0; i < extensions.length; i++) {
      Extension extension = extensions[i];
      if (extension.getDescriptor().getPluginId().equals(pluginName)) {
        attributeFile = extension.getAttribute("file");
        break;
      }
    }
    if (attributeFile != null && attributeFile.trim().equals(""))
      attributeFile = null;
    if (attributeFile != null) {
      if (LOG.isInfoEnabled()) {
        LOG.info("Attribute \"file\" is defined for plugin " + pluginName
            + " as " + attributeFile);
      }
    } else {
      // if (LOG.isWarnEnabled()) {
      // LOG.warn("Attribute \"file\" is not defined in plugin.xml for
      // plugin "+pluginName);
      // }
    }

    String file = conf.get("urlfilter.suffix.file");
]]>
</codefragment>
</duplication>
<duplication lines="17" tokens="137">
<file line="249" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\java\org\apache\nutch\parse\html\HtmlParser.java"/>
<file line="187" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\java\org\apache\nutch\parse\tika\TikaParser.java"/>
<codefragment>
<![CDATA[
    if (metaTags.getRefresh()) {
      status.setMinorCode((int) ParseStatusCodes.SUCCESS_REDIRECT);
      status.getArgs().add(new Utf8(metaTags.getRefreshHref().toString()));
      status.getArgs().add(
          new Utf8(Integer.toString(metaTags.getRefreshTime())));
    }

    Parse parse = new Parse(text, title, outlinks, status);
    parse = htmlParseFilters.filter(url, page, parse, metaTags, root);

    if (metaTags.getNoCache()) { // not okay to cache
      page.getMetadata().put(new Utf8(Nutch.CACHING_FORBIDDEN_KEY),
          ByteBuffer.wrap(Bytes.toBytes(cachingPolicy)));
    }

    return parse;
  }
]]>
</codefragment>
</duplication>
<duplication lines="41" tokens="136">
<file line="49" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\api\model\response\JobInfo.java"/>
<file line="40" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\webui\client\model\JobInfo.java"/>
<codefragment>
<![CDATA[
  public String getMsg() {
    return msg;
  }

  public void setMsg(String msg) {
    this.msg = msg;
  }

  public State getState() {
    return state;
  }

  public void setState(State state) {
    this.state = state;
  }

  public Map<String, Object> getResult() {
    return result;
  }

  public void setResult(Map<String, Object> result) {
    this.result = result;
  }

  public Map<String, Object> getArgs() {
    return args;
  }

  public void setArgs(Map<String, Object> args) {
    this.args = args;
  }

  public String getConfId() {
    return confId;
  }

  public void setConfId(String confId) {
    this.confId = confId;
  }

  public String getId() {
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="127">
<file line="28" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\test\org\apache\nutch\util\TestPrefixStringMatcher.java"/>
<file line="28" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\test\org\apache\nutch\util\TestSuffixStringMatcher.java"/>
<codefragment>
<![CDATA[
  private final static int MAX_SUFFIX_LEN = 10;
  private final static int NUM_TEST_INPUTS_PER_ROUND = 100;
  private final static int MAX_INPUT_LEN = 20;

  private final static char[] alphabet = new char[] { 'a', 'b', 'c', 'd',
  // 'e', 'f', 'g', 'h', 'i', 'j',
  // 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
  // 'u', 'v', 'w', 'x', 'y', 'z', '1', '2', '3', '4',
  // '5', '6', '7', '8', '9', '0'
  };

  private String makeRandString(int minLen, int maxLen) {
    int len = minLen + (int) (Math.random() * (maxLen - minLen));
    char[] chars = new char[len];

    for (int pos = 0; pos < len; pos++) {
      chars[pos] = alphabet[(int) (Math.random() * alphabet.length)];
    }

    return new String(chars);
  }

  @Test
  public void testSuffixMatcher() {
]]>
</codefragment>
</duplication>
<duplication lines="17" tokens="125">
<file line="111" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\crawl\DbUpdaterJob.java"/>
<file line="205" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\fetcher\FetcherJob.java"/>
<codefragment>
<![CDATA[
    currentJob.waitForCompletion(true);
    ToolUtil.recordJobStatus(null, currentJob, results);
    return results;
  }

  private MapFieldValueFilter<String, WebPage> getBatchIdFilter(String batchId) {
    if (batchId.equals(Nutch.ALL_CRAWL_ID.toString())) {
      return null;
    }
    MapFieldValueFilter<String, WebPage> filter = new MapFieldValueFilter<String, WebPage>();
    filter.setFieldName(WebPage.Field.MARKERS.toString());
    filter.setFilterOp(FilterOp.EQUALS);
    filter.setFilterIfMissing(true);
    filter.setMapKey(Mark.GENERATE_MARK.getName());
    filter.getOperands().add(new Utf8(batchId));
    return filter;
  }
]]>
</codefragment>
</duplication>
<duplication lines="13" tokens="121">
<file line="57" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestImageMetadata.java"/>
<file line="88" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestOOParser.java"/>
<codefragment>
<![CDATA[
      File file = new File(sampleDir + fileSeparator + sampleFiles[i]);
      byte[] bytes = new byte[(int) file.length()];
      DataInputStream in = new DataInputStream(new FileInputStream(file));
      in.readFully(bytes);
      in.close();

      WebPage page = WebPage.newBuilder().build();
      page.setBaseUrl(new Utf8(urlString));
      page.setContent(ByteBuffer.wrap(bytes));
      String mtype = mimeutil.getMimeType(file);
      page.setContentType(new Utf8(mtype));

      parse = new ParseUtil(conf).parse(urlString, page);
]]>
</codefragment>
</duplication>
<duplication lines="16" tokens="120">
<file line="281" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\test\org\apache\nutch\parse\html\TestDOMContentUtils.java"/>
<file line="333" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\DOMContentUtilsTest.java"/>
<codefragment>
<![CDATA[
  public void testGetOutlinks() throws Exception {
    if (testDOMs[0] == null)
      setup();
    for (int i = 0; i < testPages.length; i++) {
      ArrayList<Outlink> outlinks = new ArrayList<Outlink>();
      if (i == SKIP) {
        conf.setBoolean("parser.html.form.use_action", false);
        utils.setConf(conf);
      } else {
        conf.setBoolean("parser.html.form.use_action", true);
        utils.setConf(conf);
      }
      utils.getOutlinks(testBaseHrefURLs[i], outlinks, testDOMs[i]);
      Outlink[] outlinkArr = new Outlink[outlinks.size()];
      outlinkArr = outlinks.toArray(outlinkArr);
      compareOutlinks(i, answerOutlinks[i], outlinkArr);
]]>
</codefragment>
</duplication>
<duplication lines="33" tokens="113">
<file line="27" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\api\model\response\NutchStatus.java"/>
<file line="24" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\webui\client\model\NutchStatus.java"/>
<codefragment>
<![CDATA[
public class NutchStatus implements Serializable {

  private Date startDate;
  private Set<String> configuration;
  private Collection<JobInfo> jobs;
  private Collection<JobInfo> runningJobs;

  public Date getStartDate() {
    return startDate;
  }

  public void setStartDate(Date startDate) {
    this.startDate = startDate;
  }

  public Set<String> getConfiguration() {
    return configuration;
  }

  public void setConfiguration(Set<String> configuration) {
    this.configuration = configuration;
  }

  public Collection<JobInfo> getJobs() {
    return jobs;
  }

  public void setJobs(Collection<JobInfo> jobs) {
    this.jobs = jobs;
  }

  public Collection<JobInfo> getRunningJobs() {
    return runningJobs;
]]>
</codefragment>
</duplication>
<duplication lines="12" tokens="112">
<file line="74" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\util\Histogram.java"/>
<file line="95" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\util\Histogram.java"/>
<codefragment>
<![CDATA[
  public List<E> sortByValue() {
    List<Map.Entry<E, HistogramEntry>> list = new Vector<Map.Entry<E, HistogramEntry>>(
        map.entrySet());

    // Sort the list using an annonymous inner class implementing Comparator for
    // the compare method
    java.util.Collections.sort(list,
        new Comparator<Map.Entry<E, HistogramEntry>>() {
          public int compare(Map.Entry<E, HistogramEntry> entry,
              Map.Entry<E, HistogramEntry> entry1) {
            return (entry.getValue().equals(entry1.getValue()) ? 0 : (entry
                .getValue().value > entry1.getValue().value ? 1 : -1));
]]>
</codefragment>
</duplication>
<duplication lines="20" tokens="111">
<file line="70" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-swf\src\test\org\apache\nutch\parse\swf\TestSWFParser.java"/>
<file line="54" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-zip\src\test\org\apache\nutch\parse\zip\TestZipParser.java"/>
<codefragment>
<![CDATA[
  }

  protected void setUp() {}

  protected void tearDown() {}

  @Test
  public void testIt() throws ProtocolException, ParseException {
    String urlString;
    Protocol protocol;
    Content content;
    Parse parse;

    Configuration conf = NutchConfiguration.create();
    for (int i = 0; i < sampleFiles.length; i++) {
      urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];

      protocol = new ProtocolFactory(conf).getProtocol(urlString);
      content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();
      parse = new ParseUtil(conf).parseByExtensionId("parse-zip",content).get(content.getUrl());
]]>
</codefragment>
</duplication>
<duplication lines="44" tokens="110">
<file line="481" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\Host.java"/>
<file line="2804" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\WebPage.java"/>
<codefragment>
<![CDATA[
    }

    /**
     * Gets the value of the 'metadata' field. A multi-valued metadata container
     * used for storing everything from structured WebPage characterists, to
     * ad-hoc extraction and metadata augmentation for any given WebPage.
     */
    public java.util.Map<java.lang.CharSequence, java.nio.ByteBuffer> getMetadata() {
      throw new java.lang.UnsupportedOperationException(
          "Get is not supported on tombstones");
    }

    /**
     * Sets the value of the 'metadata' field. A multi-valued metadata container
     * used for storing everything from structured WebPage characterists, to
     * ad-hoc extraction and metadata augmentation for any given WebPage. * @param
     * value the value to set.
     */
    public void setMetadata(
        java.util.Map<java.lang.CharSequence, java.nio.ByteBuffer> value) {
      throw new java.lang.UnsupportedOperationException(
          "Set is not supported on tombstones");
    }

    /**
     * Checks the dirty status of the 'metadata' field. A field is dirty if it
     * represents a change that has not yet been written to the database. A
     * multi-valued metadata container used for storing everything from
     * structured WebPage characterists, to ad-hoc extraction and metadata
     * augmentation for any given WebPage. * @param value the value to set.
     */
    public boolean isMetadataDirty(
        java.util.Map<java.lang.CharSequence, java.nio.ByteBuffer> value) {
      throw new java.lang.UnsupportedOperationException(
          "IsDirty is not supported on tombstones");
    }

    /**
     * Gets the value of the 'batchId' field. A batchId that this WebPage is
     * assigned to. WebPage's are fetched in batches, called fetchlists. Pages
     * are partitioned but can always be associated and fetched alongside pages
     * of similar value (within a crawl cycle) based on batchId.
     */
    public java.lang.CharSequence getBatchId() {
]]>
</codefragment>
</duplication>
<duplication lines="28" tokens="110">
<file line="19" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\indexer\solr\SolrConstants.java"/>
<file line="19" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\indexer-solr\src\java\org\apache\nutch\indexwriter\solr\SolrConstants.java"/>
<codefragment>
<![CDATA[
public interface SolrConstants {
  public static final String SOLR_PREFIX = "solr.";

  public static final String SERVER_URL = SOLR_PREFIX + "server.url";

  public static final String COMMIT_SIZE = SOLR_PREFIX + "commit.size";

  public static final String COMMIT_INDEX = SOLR_PREFIX + "commit.index";

  public static final String MAPPING_FILE = SOLR_PREFIX + "mapping.file";

  public static final String USE_AUTH = SOLR_PREFIX + "auth";

  public static final String USERNAME = SOLR_PREFIX + "auth.username";

  public static final String PASSWORD = SOLR_PREFIX + "auth.password";

  public static final String ID_FIELD = "id";

  public static final String URL_FIELD = "url";

  public static final String BOOST_FIELD = "boost";

  public static final String TIMESTAMP_FIELD = "tstamp";

  public static final String DIGEST_FIELD = "digest";

}
]]>
</codefragment>
</duplication>
<duplication lines="11" tokens="109">
<file line="109" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\util\PrefixStringMatcher.java"/>
<file line="104" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\util\SuffixStringMatcher.java"/>
<codefragment>
<![CDATA[
    String[] tests = { "a", "ac", "abcd", "abcdefg", "apple", "aa", "aac",
        "aaccca", "abaz", "baz", "bazooka", "fo", "foobar", "kite", };

    for (int i = 0; i < tests.length; i++) {
      System.out.println("testing: " + tests[i]);
      System.out.println("   matches: " + matcher.matches(tests[i]));
      System.out.println("  shortest: " + matcher.shortestMatch(tests[i]));
      System.out.println("   longest: " + matcher.longestMatch(tests[i]));
    }
  }
}
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="108">
<file line="88" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestOOParser.java"/>
<file line="65" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestRTFParser.java"/>
<codefragment>
<![CDATA[
    File file = new File(sampleDir + fileSeparator + rtfFile);
    byte[] bytes = new byte[(int) file.length()];
    DataInputStream in = new DataInputStream(new FileInputStream(file));
    in.readFully(bytes);
    in.close();

    WebPage page = WebPage.newBuilder().build();
    page.setBaseUrl(new Utf8(urlString));
    page.setContent(ByteBuffer.wrap(bytes));
    String mtype = mimeutil.getMimeType(file);
    page.setContentType(new Utf8(mtype));

    parse = new ParseUtil(conf).parse(urlString, page);

    String title = parse.getTitle();
]]>
</codefragment>
</duplication>
<duplication lines="34" tokens="108">
<file line="579" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\ParseStatus.java"/>
<file line="574" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\java\org\apache\nutch\storage\ProtocolStatus.java"/>
<codefragment>
<![CDATA[
    public boolean isCodeDirty(java.lang.Integer value) {
      throw new java.lang.UnsupportedOperationException(
          "IsDirty is not supported on tombstones");
    }

    /**
     * Gets the value of the 'args' field. Optional arguments supplied to
     * compliment and/or justify the response code.
     */
    public java.util.List<java.lang.CharSequence> getArgs() {
      throw new java.lang.UnsupportedOperationException(
          "Get is not supported on tombstones");
    }

    /**
     * Sets the value of the 'args' field. Optional arguments supplied to
     * compliment and/or justify the response code. * @param value the value to
     * set.
     */
    public void setArgs(java.util.List<java.lang.CharSequence> value) {
      throw new java.lang.UnsupportedOperationException(
          "Set is not supported on tombstones");
    }

    /**
     * Checks the dirty status of the 'args' field. A field is dirty if it
     * represents a change that has not yet been written to the database.
     * Optional arguments supplied to compliment and/or justify the response
     * code. * @param value the value to set.
     */
    public boolean isArgsDirty(java.util.List<java.lang.CharSequence> value) {
      throw new java.lang.UnsupportedOperationException(
          "IsDirty is not supported on tombstones");
    }
]]>
</codefragment>
</duplication>
<duplication lines="13" tokens="107">
<file line="57" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestImageMetadata.java"/>
<file line="65" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\TestRTFParser.java"/>
<codefragment>
<![CDATA[
    File file = new File(sampleDir + fileSeparator + rtfFile);
    byte[] bytes = new byte[(int) file.length()];
    DataInputStream in = new DataInputStream(new FileInputStream(file));
    in.readFully(bytes);
    in.close();

    WebPage page = WebPage.newBuilder().build();
    page.setBaseUrl(new Utf8(urlString));
    page.setContent(ByteBuffer.wrap(bytes));
    String mtype = mimeutil.getMimeType(file);
    page.setContentType(new Utf8(mtype));

    parse = new ParseUtil(conf).parse(urlString, page);
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="103">
<file line="296" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-html\src\test\org\apache\nutch\parse\html\TestDOMContentUtils.java"/>
<file line="348" path="C:\Users\ginay\git\arcade\subject_systems\nutch\src\plugin\parse-tika\src\test\org\apache\nutch\parse\tika\DOMContentUtilsTest.java"/>
<codefragment>
<![CDATA[
      compareOutlinks(i, answerOutlinks[i], outlinkArr);
    }
  }

  private static final void appendOutlinks(StringBuffer sb, Outlink[] o) {
    for (int i = 0; i < o.length; i++) {
      sb.append(o[i].toString());
      sb.append(System.getProperty("line.separator"));
    }
  }

  private static final String outlinksString(Outlink[] o) {
    StringBuffer sb = new StringBuffer();
    appendOutlinks(sb, o);
    return sb.toString();
  }

  private static final void compareOutlinks(int test, Outlink[] o1, Outlink[] o2) {
]]>
</codefragment>
</duplication>
</pmd-cpd>